# R Programming Basics

-   R has two main parts: data structures and functions.

    -   Data structures help store and organize data so it can be used efficiently.

```{r}
 income <- c(1000, 4000, 3400, 9700, 9800)
 income
```

    -   Functions tell R what to do.

```{r}
mean(income)
summary(income)
```

## Data structures

-   R’s basic data structures can be grouped by:

    -   Their dimensions (1D, 2D, or multi-dimensional).
    -   Whether they store one type of data (homogeneous) or different types of data (heterogeneous).

-   This gives us five common data structures in R:

    -   Homogeneous (same type of data): Vectors, Matrices, Arrays
    -   Heterogeneous (different types of data): Data Frames, Lists

```{r   out.width = "100%", echo = FALSE, fig.align='center', fig.cap="Data Structure Types. Image Source: http://venus.ifca.unican.es/Rintro/dataStruct.html" }
knitr::include_graphics("fig/3_dataStructures.png")
```

-   Among these, vectors and data frames are the most commonly used data structures in practical applications.

### Vectors

**Creating vectors**

Syntax

``` r
vector_name <- c(element1, element2, element3)
```

Example

```{r, comment=NA}
x <- c(5, 6, 3, 1, 100)
x
```

**Combine two vectors**

```{r}
p <- c(1, 2, 3)
p
q <- c(10, 20, 30)
q
r <- c(p, q)
r

```

**Vector with charactor elements**

```{r}
countries <- c("Sri Lanka", "Afghanistan", "Bangladesh", "Bhutan", "India", "Iran", "Maldives", "Nepal", "Pakistan")

countries

```

**Logical vector**

```{r}
result <- c(TRUE, FALSE, FALSE, TRUE, FALSE)
result
```

**Simplifying vector creation**

-   `rep` is a function in R that repeats the values in a vector

```{r}
id <- 1:10
id
treatment <- rep(1:3, each=2)
treatment
```

**Vector operations**

```{r}
x <- c(1, 2, 3)
y <- c(10, 20, 30)
x+y
p <- c(100, 1000)
x+p
```

## Data Frames

**Required R package to deal with data frames**

```{r, comment=NA, message=TRUE, warning=TRUE}
library(tidyverse)
```

**Create a tibble**

-   A tibble is an improved version of a traditional data frame in R, designed to be more user-friendly and consistent.

-   It is part of the `tidyverse` package and makes it easier to view and analyze data, especially when working with large datasets.

Lets consider the following example

**GDP per capita (current US\$) - South Asia**

*Data Source : https://data.worldbank.org/*

| Country     | Most Recent Year | Most Recent Value |
|-------------|------------------|-------------------|
| Afghanistan | 2023             | 415.7             |
| Bangladesh  | 2023             | 2,551.0           |
| Bhutan      | 2023             | NA                |
| India       | 2023             | 2,480.8           |
| Maldives    | 2023             | 12,530.4          |
| Nepal       | 2023             | 1,377.6           |
| Pakistan    | 2023             | 1,365.3           |
| Sri Lanka   | 2023             | 3,828.0           |

```{r, comment=NA, message=FALSE}
country <- c("Afghanistan", "Bangladesh", "Bhutan", "India", "Maldives",
             "Nepal", "Pakistan", "Sri Lanka")
year <- c(rep(2023,8))
value <- c(415.7, 2551.0, NA, 2480.8, 12530.4, 1377.6, 1365.3, 3828.0)

final <- tibble(Country = country, Recent_Year = year, Value = value )
final
```

## Functions in R

-   In R, functions are blocks of code that perform specific tasks.

-   They take input values (called arguments), process them, and return an output.

-   Functions help automate repetitive tasks and make code more efficient.

-   There are two main types of functions in R:

    -   Built-in functions – Predefined in R (e.g., mean(), sum(), rep()).

```{r, comment=NA, message=FALSE}

summary(final$Value)
```

```         
- User-defined functions – Created by users for specific needs using function().
```

## Subsetting

```{r, comment=NA}
final

final[1, 1]
```

```{r, comment=NA}

final[, 1]
final[1, ]
final$Country
```

## Help file for Built-in functions

-   To access the help file for a built-in function in R, you can use either `?` or the `help()` function.

-   Running either of these commands will open the help page for the specified function.

= For example, using `?summary` or `help(summary)` will display the help file for the summary function, which is part of the base R package.

```{r, eval=FALSE}
?summary

# or 

help(summary)
```

```{r out.width = "100%", echo = FALSE,fig.align='center', fig.cap="Help Page"}

knitr::include_graphics("fig/5_summaryhelp.png")
```

## Commenting

```{r}
mean(final$Value) # Calculate the average GDP value
```

When you go to the help page for the `mean()` function, you'll find that by default, the `na.rm` argument is set to `FALSE`. This means that if the data contains missing values (NA), they will be included in the calculation, and the result will also be NA. To calculate the mean while ignoring missing values, you should set `na.rm = TRUE`.

```{r}
mean(final$Value, na.rm = TRUE) # Calculate the average GDP value
```

## Pipe operator (`|>`)

-   The pipe operator (`|>`) in the base R package helps improve the readability of your code.

-   It takes the output of one function and passes it directly into another function as an argument, making the steps in your data analysis more connected.

-   Instead of using nested function calls like `function(first_input, other_inputs)`, you can write the same command in a simpler format: `first_input |> function(other_inputs)`.

```{r   out.width = "100%", echo = FALSE, fig.align='center', fig.cap="Pipe Operator"}
knitr::include_graphics("fig/4_pipeillustration.png")
```

-   Therefore, using the pipe operator allows you to chain multiple operations together in a way that is easier to read and understand compared to nested function calls.

```{r}
# Nested function call
mean(final$Value, na.rm = TRUE)
```

```{r}
# Using pipe operator) 
final$Value |> mean(na.rm=TRUE)
```
